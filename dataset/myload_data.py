import PIL.Imageimport numpy as npimport osimport randomimport csv#根据csv读图片def read_datalist(listfile):    images_paths = list()    labels = list()    f = csv.reader(open(listfile, 'r'))    for line in f:        tmpimagefile = line[0]        tmplabel = int(line[1])        assert os.path.exists(tmpimagefile), "dataset root: {} does not exist.".format(tmpimagefile)        images_paths.append(tmpimagefile)        labels.append(tmplabel)    return images_paths, labelsdef load_per_data(image_path):    img = PIL.Image.open(image_path)    img_array = np.array(img)    txtfile =image_path.replace('bmp', 'txt')    pointlist = list()    random.seed(0)    if os.path.isfile(txtfile):        with open(txtfile, "r") as f:            for eachline in f:                tmp = eachline.split()                tmppoint = np.array([int(tmp[0]), int(tmp[1])])                if 0==tmppoint[0] & 0==tmppoint[1]:                    if len(pointlist) == 0:                        continue                    points_arrary = np.array(pointlist)                    mins = np.min(points_arrary, axis=0)                    maxs = np.max(points_arrary, axis=0)                    height_length = np.abs(maxs[0] - mins[0])                    width_length = np.abs(maxs[1] - mins[1])                    longer_length = height_length if height_length > width_length else width_length                    shorter_length = height_length if height_length <= width_length else width_length                    base_proportion = 144.0/96.0                    temp_length = longer_length                    base_per = 1.1                    base_per = base_per + random.uniform(0, 0.1)                    temp_length = temp_length * base_per                    temp_ano_length = temp_length / base_proportion                    difference_length = (temp_length - longer_length) / 2                    difference_ano_length = (temp_ano_length - shorter_length) / 2                    if longer_length == height_length:                        mins0_length_to_zero = int(mins[0] - difference_length)                        mins1_length_to_zero = int(mins[1] - difference_ano_length)                        maxs0_length_to_most = int(maxs[0] + difference_length)                        maxs1_length_to_most = int(maxs[1] + difference_ano_length)                        if temp_length > img_array.shape[0]:                            mins0_length_to_zero = 0                            maxs0_length_to_most = img_array.shape[0] - 1                        elif mins0_length_to_zero < 0:                            maxs0_length_to_most = maxs0_length_to_most - mins0_length_to_zero                            mins0_length_to_zero = 0                        elif maxs0_length_to_most > img_array.shape[0]:                            mins0_length_to_zero = mins0_length_to_zero - (maxs0_length_to_most - img_array.shape[0])                            maxs0_length_to_most = img_array.shape[0] - 1                        if temp_ano_length > img_array.shape[1]:                            mins1_length_to_zero = 0                            maxs1_length_to_most = img_array.shape[1] - 1                        elif mins1_length_to_zero < 0:                            maxs1_length_to_most = maxs1_length_to_most - mins1_length_to_zero                            mins1_length_to_zero = 0                        elif maxs1_length_to_most > img_array.shape[1]:                            mins1_length_to_zero = mins1_length_to_zero - (maxs1_length_to_most - img_array.shape[1])                            maxs1_length_to_most = img_array.shape[1] - 1                        mins = [mins0_length_to_zero, mins1_length_to_zero]                        maxs = [maxs0_length_to_most, maxs1_length_to_most]                    elif longer_length == width_length:                        mins1_length_to_zero = int(mins[1] - difference_length)                        mins0_length_to_zero = int(mins[0] - difference_ano_length)                        maxs1_length_to_most = int(maxs[1] + difference_length)                        maxs0_length_to_most = int(maxs[0] + difference_ano_length)                        if temp_length > img_array.shape[1]:                            mins1_length_to_zero = 0                            maxs1_length_to_most = img_array.shape[1] - 1                        elif mins1_length_to_zero < 0:                            maxs1_length_to_most = maxs1_length_to_most - mins1_length_to_zero                            mins1_length_to_zero = 0                        elif maxs1_length_to_most > img_array.shape[1]:                            mins1_length_to_zero = mins1_length_to_zero - (maxs1_length_to_most - im.shape[1])                            maxs1_length_to_most = img_array.shape[1] - 1                        if temp_ano_length > img_array.shape[0]:                            mins0_length_to_zero = 0                            maxs0_length_to_most = img_array.shape[0] - 1                        elif mins0_length_to_zero < 0:                            maxs0_length_to_most = maxs0_length_to_most - mins0_length_to_zero                            mins0_length_to_zero = 0                        elif maxs0_length_to_most > img_array.shape[0]:                            mins0_length_to_zero = mins0_length_to_zero - (maxs0_length_to_most - img_array.shape[0])                            maxs0_length_to_most = img_array.shape[0] - 1                        mins = [mins0_length_to_zero, mins1_length_to_zero]                        maxs = [maxs0_length_to_most, maxs1_length_to_most]                    imROI = img_array[mins[1]:maxs[1], mins[0]:maxs[0],:]                    im = PIL.Image.fromarray(imROI)                    continue                # print(tmppoint)                pointlist.append(tmppoint)    return imif __name__ == '__main__':    imROI_list = load_per_data(        'D:/study/Zhongnan_plaqueClassification/low/20161_5.bmp',    )    imROI_list.show()